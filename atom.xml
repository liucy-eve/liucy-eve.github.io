<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术随笔</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liucy.xyz/"/>
  <updated>2020-04-01T07:36:19.476Z</updated>
  <id>http://liucy.xyz/</id>
  
  <author>
    <name>liucy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis的三种集群模式和数据同步</title>
    <link href="http://liucy.xyz/2020/04/01/Redis%E9%9B%86%E7%BE%A4%E5%92%8C%E5%90%8C%E6%AD%A5/"/>
    <id>http://liucy.xyz/2020/04/01/Redis%E9%9B%86%E7%BE%A4%E5%92%8C%E5%90%8C%E6%AD%A5/</id>
    <published>2020-04-01T07:31:10.147Z</published>
    <updated>2020-04-01T07:36:19.476Z</updated>
    
    <content type="html"><![CDATA[<p>Reids做为目前最流行的高速缓存中间件，不仅在工作中频繁使用到，在求职过程中也是面试的热点。Redis作为一个高并发中间件，如何保证高可用自然而然的成为了一个痛点。目前比较主流的Redis高可用架构方案为三种：主从模式，哨兵模式，分片模式。下面我们来分别聊一聊这三种架构方案。</p><a id="more"></a><h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p><img src="https://liucy-blog.oss-cn-beijing.aliyuncs.com/Redis%E4%B8%BB%E4%BB%8E.png" alt="主从模式"><br>主从模式是三种模式中最简单，功能最单一的一种Redis集群模式，从上图可以看出在一主三从的模式下，客户端直接调用Master节点，Master节点再将数据同步到每个Slave节点。在这种模式下，Slave节点本质上是Master节点的一个数据备份，保证Master节点在异常宕机的情况下，无需同步数据或者极少数量的数据同步，就可以快速切换到Slave节点，保证业务的正常运行。但是这里的Master-&gt;Slave的切换并不是主从集群自动实现的，它需要由运维人员去手动操作。</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><img src="https://liucy-blog.oss-cn-beijing.aliyuncs.com/Redis%E5%93%A8%E5%85%B5.png" alt="哨兵模式"><br>Redis Sentinel模式即哨兵模式，此模式下一般存在两种集群，一种是Sentinel集群，另一种是Redis集群，一个Sentinel集群可以监控多个Redis集群。正如上图描述的Redis Sentinel集群，在这个集群中，由哨兵1，哨兵2，哨兵3组成的哨兵集群对Redis集群1和Redis集群2同时进行监控。集群1和集群2都是采用了主从模式的Redis集群，但是整个集群的健康状态监控托管给了Sentinel集群，当某个集群内的Master节点发生宕机时，Sentinel自动将Slave节点替换为Master节点。可以看出哨兵模式比单纯的主从模式增加了故障迁移的处理，而这种处理是基于对Redis节点监控实现的。</p><h3 id="分片模式"><a href="#分片模式" class="headerlink" title="分片模式"></a>分片模式</h3><p><img src="https://liucy-blog.oss-cn-beijing.aliyuncs.com/Redis%20Cluster.png" alt="分片模式"><br>Redis Cluster模式即分片模式，从上图的三主三备的架构来看，Redis Cluster集群与上面两种集群最大的区别在于这种模式下存在多个Master节点。Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽，在这种模式下对业务方来说，每次读写操作可能需要N次才能成功，N=Master节点数量。这种模式其实采用的是分布式系统横向拆分的一种思路，通过设置多个Master进行读写，那么Master节点本身的瓶颈就不再是问题。同时Master节点互相监控，相对于哨兵模式，少了Sentinel集群，系统复杂度和稳定性都更加优秀。因此Redis Cluster集群模式为Redis官方推荐的集群模式。</p><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>上面我们将了Redis三种集群模式，不管采用哪种集群模式，Redis主从节点之间数据同步的原理都是一致的，下面我们再来看看Redis主从节点是怎么进行同步的。</p><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><p>无论是初次连接还是重新连接，当建立一个从节点时，从节点都会像主节点发送<strong>SYNC</strong>命令。接到<strong>SYNC</strong>的主节点将开始执行<strong>BGSAVE</strong>，并在保存操作执行期间，将所有新执行的命令写到一个缓冲区里面。当<strong>BGSAVE</strong>执行完毕后，主节点将生成的RDB文件发送给从节点，从节点接收这个RDB文件并将数据加载到内存。<br>当从节点把RDB数据加载到内存之后，那么截止到主节点接收到<strong>SYNC</strong>时，从节点的数据和主节点的数据就已经一致了。那么主节点在执行BGSAVE期间以及后续的数据一致性怎么保证呢？</p><h3 id="命令广播"><a href="#命令广播" class="headerlink" title="命令广播"></a>命令广播</h3><p>在执行完同步操作之后，主从服务器之间数据库状态已经相同了。但这个状态并非一成不变，如果主服务器执行了写操作，那么主服务器的数据库状态就会修改，并导致主从服务器状态不再一致。所以为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。<br><strong>BGSAVE</strong>期间以及后续的数据一致性都通过命令广播的方式，在从节点上再执行一遍，这样就保证了主从节点的一致性。</p><h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>在Redis2.8以前，如果因为网络问题，从服务器与主服务器断开，那么重连以后需要重新进行全量同步。<br>从 Redis 2.8 开始， 在网络连接短暂性失效之后， 主从服务器可以尝试继续执行原有的复制进程（process）， 而不一定要执行完整重同步操作。</p><p>这个特性需要主服务器为被发送的复制流创建一个内存缓冲区（in-memory backlog）， 并且主服务器和所有从服务器之间都记录一个复制偏移量（replication offset）和一个主服务器 ID （master run id）， 当出现网络连接断开时， 从服务器会重新连接， 并且向主服务器请求继续执行原来的复制进程：</p><p>如果从服务器记录的主服务器 ID 和当前要连接的主服务器的 ID 相同， 并且从服务器记录的偏移量所指定的数据仍然保存在主服务器的复制流缓冲区里面， 那么主服务器会向从服务器发送断线时缺失的那部分数据， 然后复制工作可以继续执行。<br>否则的话， 从服务器就要执行完整重同步操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Reids做为目前最流行的高速缓存中间件，不仅在工作中频繁使用到，在求职过程中也是面试的热点。Redis作为一个高并发中间件，如何保证高可用自然而然的成为了一个痛点。目前比较主流的Redis高可用架构方案为三种：主从模式，哨兵模式，分片模式。下面我们来分别聊一聊这三种架构方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://liucy.xyz/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="中间件" scheme="http://liucy.xyz/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="redis" scheme="http://liucy.xyz/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java中的Fail-Fast和Fail-Safe</title>
    <link href="http://liucy.xyz/2020/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84Fail-Fast%E5%92%8CFail-Safe/"/>
    <id>http://liucy.xyz/2020/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84Fail-Fast%E5%92%8CFail-Safe/</id>
    <published>2020-03-20T07:11:46.178Z</published>
    <updated>2020-03-26T07:44:51.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong><a href="https://en.wikipedia.org/wiki/Fail-fast" target="_blank" rel="noopener">Fail-Fast</a>和<a href="https://en.wikipedia.org/wiki/Fail-safe" target="_blank" rel="noopener">Fail-Safe</a></strong>本质上是系统设计中的两种策略，是系统安全的一种体现，在维基百科中分别给出了如下定义：</p><a id="more"></a><ul><li><p><strong>Fail-Fast</strong> ：</p><blockquote></blockquote><p>In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system’s state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.</p></li><li><p><strong>Fail-Safe</strong> ：</p><blockquote></blockquote><p>In engineering, a fail-safe is a design feature or practice that in the event of a specific type of failure, inherently responds in a way that will cause no or minimal harm to other equipment, to the environment or to people. Unlike inherent safety to a particular hazard, a system being “fail-safe” does not mean that failure is impossible or improbable, but rather that the system’s design prevents or mitigates unsafe consequences of the system’s failure. That is, if and when a “fail-safe” system fails, it remains at least as safe as it was before the failure.Since many types of failure are possible, failure mode and effects analysis is used to examine failure situations and recommend safety design and procedures.</p></li></ul><p>简单的来说，Fail-Fast的逻辑是在系统出现异常的时候，迅速抛出异常，避免后续操作对系统造成更大的破坏。Fail-Safe则是即使系统在有特定失效下，也不会造成对人员或其他设备的伤害（或者将伤害最小化）。即Fail-Fast是在异常发生时，阻止当前操作继续执行，Fail-Safe则是一种兜底策略，或者是防呆设计，在系统发生异常时，保证系统满足最基本的安全策略。</p><h2 id="Java中的Fail-Fast和Fail-Safe"><a href="#Java中的Fail-Fast和Fail-Safe" class="headerlink" title="Java中的Fail-Fast和Fail-Safe"></a>Java中的Fail-Fast和Fail-Safe</h2><p>在Java中，集合迭代器分为两种, Fail fast and Non Fail-fast iterators。注意这里的表述，并不是Fail-Fast和Fail-Safe这两种迭代器而是Fail-Fast和Non Fail-Fast。我为什么这么表述呢，这里可以结合上面对Fail-Fast和Fail-Safe的定义来看，Fail-Fast和Fail-Safe两者本身就不是非此即彼的关系，而且两种不同的安全策略。下面我们根据Java Doc和源码具体分析一下Java中到底是怎么实现Fail-Fast和到底有没有Fail-Safe机制的设计。</p><h3 id="Fail-Fast-Iterators"><a href="#Fail-Fast-Iterators" class="headerlink" title="Fail-Fast Iterators"></a>Fail-Fast Iterators</h3><p>对Java中Fail-Fast有一定了解的同学，应该都知道，Fail-Fast的迭代器在遍历集合的时候如果集合出现了修改，新增等操作则迭代器会直接抛出<strong>ConcurrentModificationException</strong>停止遍历当前集合，这就是Fail-Fast的体现。下面我们针对HashMap来具体分析。<br><strong><a href="https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html" target="_blank" rel="noopener">HashMap</a></strong>的Java Doc中进行了针对迭代器有如下描述 :</p><blockquote><p>The iterators returned by all of this class’s “collection view methods” are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator’s own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.<br>Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.</p></blockquote><p>在HashMap的Java Doc中明确表明了该类的迭代器是Fail-Fast的，同时Java Doc也指出该迭代器并不保证并发修改的时候一定会抛出异常，所以不应该基于该Fail-Fast机制去编写程序，该机制应该只用来检测BUG。HashMap Fail-Fast的实现代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">        Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">        <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            Node&lt;K,V&gt;[] t = table;</span><br><span class="line">            current = next = <span class="keyword">null</span>;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] t;</span><br><span class="line">            Node&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="comment">//当前迭代器的值和期望值不相等时就抛出ConcurrentModificationException，停止继续遍历，实现Fail-Fast机制</span></span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="Non-Fail-Fast-Iterators"><a href="#Non-Fail-Fast-Iterators" class="headerlink" title="Non Fail-Fast Iterators"></a>Non Fail-Fast Iterators</h3><p>网上大部分文章都任务JUC下面的集合是Fail-Safe的，那么我们来看下<strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html" target="_blank" rel="noopener">JUC</a></strong>的Java Doc是怎么描述的：</p><blockquote><p>Most concurrent Collection implementations (including most Queues) also differ from the usual java.util conventions in that their Iterators and Spliterators provide weakly consistent rather than fast-fail traversal:</p></blockquote><blockquote><p>they may proceed concurrently with other operations<br>they will never throw ConcurrentModificationException<br>they are guaranteed to traverse elements as they existed upon construction exactly once, and may (but are not guaranteed to) reflect any modifications subsequent to construction.</p></blockquote><p>JUC下面的集合类并没有提供Fail-Fast机制，而是提供了弱一致性，并且永远不会抛出<strong>ConcurrentModificationException</strong>,在Java Doc中并没有明确的说明这种实现就是Fail-Safe的。<br>我们再来看看<strong><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html" target="_blank" rel="noopener">CopyOnWriteArrayList</a></strong>这种普遍认为是Fail-Safe的容器是怎么描述的：</p><blockquote><p>This is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don’t want to synchronize traversals, yet need to preclude interference among concurrent threads. The “snapshot” style iterator method uses a reference to the state of the array at the point that the iterator was created. This array never changes during the lifetime of the iterator, so interference is impossible and the iterator is guaranteed not to throw ConcurrentModificationException. The iterator will not reflect additions, removals, or changes to the list since the iterator was created. Element-changing operations on iterators themselves (remove, set, and add) are not supported. These methods throw UnsupportedOperationException.</p></blockquote><p>可以看到<strong>CopyOnWriteArrayList</strong>是通过快照机制实现的weakly consistent，也就是说每个迭代器在创建的时候就被当前容器内容做一份拷贝，迭代器遍历的是快照中的数据。那么Java中的实现是Fail-Safe机制的一种实现嘛？</p><p>从Fail-Safe的定义来看，Fail-Safe本质上是一种兜底或者说是防呆的安全策略,比如现代的CPU有避免因过热而损坏的机能，若冷却风扇故障，CPU会在温度到达一临界值后停止工作，以避免元件损坏。又比如在火车号志中，未使用的号志需指向“危险”位置。所有号志的预设位置是“危险”，因此需要额外的清除信号才会使号志由“危险”变为“安全”，而火车在号志显示“安全”时才能进入。这也确保若号码系统有问题、信号手经验不足，未预期火车异常进入的情形下，火车号志不会异常的出现“安全”。所以严格意义上来说，Java中JUC下面的容器迭代器不能说是Fail-Safe的，因为他们的实现不是一种在异常情况下的兜底，他们只是弱一致性的一种体现。<p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fail-fast&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fail-Fast&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Fail-safe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fail-Safe&lt;/a&gt;&lt;/strong&gt;本质上是系统设计中的两种策略，是系统安全的一种体现，在维基百科中分别给出了如下定义：&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://liucy.xyz/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java" scheme="http://liucy.xyz/tags/java/"/>
    
      <category term="fail-safe" scheme="http://liucy.xyz/tags/fail-safe/"/>
    
      <category term="fail-fast" scheme="http://liucy.xyz/tags/fail-fast/"/>
    
  </entry>
  
</feed>
